1. 사용자가 http://localhost:3000에 접속하면 서버가 브라우저에게 index.html을 보내줌
2. index.html에 client.js와 xhr-hook.js가 포함되어있고, 브라우저가 이를 읽으면서 자동으로 실행됨
3. 브라우저가 xhr-hook.js를 읽는순간 4000번 서버로부터 xhr-hook.js가 브라우저에 로드가 됨
4. xhr-hook.js가 실행되면서 브라우저의 기본 XMLHttpRequest객체를 새로만든 가짜객체로 교체함
(이 시점에서 후킹 성공, 엄밀히 말하면 XHR객체 바꿔치기 성공)(프로토타입 덮어쓰기여서 이후 생성되는 XHR객체도 xhr-hook.js의 객체를 사용하게 됨)
5. 사용자가 http://localhost:3000에서 여러 전송 버튼들을 누르면, client.js는 정석대로 XHR객체를 생성하여 서버로 전송을 시도합니다
6. 하지만 이미 후킹된 가짜 XHR객체가 client.js가 할려던 행동들을 대신 합니다. open(), setRequestHeader(), send() 등등
7. 가짜 XHR객체는 원래 가려던 신호를 복사해서 5001,5002,5003번 서버에 멀티 오리진으로 전송합니다.(여러개의 C2서버에 복사하기)
8. 처음에 복사한 신호는 원래 가려던 서버(3000번)에도 똑같이 보내줍니다.(사용자나 서버 입장에서는 정상적으로 신호가 주고 받아진것 처럼 보임)(물론 F12 눌러서 보면 들킴)
9. CMD창으로 3000번,5001번,5002번,5003번의 서버에 수집로그가 뜨는 것을 확인하실 수 있습니다.
10. 수집이 돼서 DB에서 확인할 수 있는건 아닙니다. 그냥 이름만 collect서버이고, 들어온 페이로드를 json.parse를 통해서 적당히 콘솔로그만 띄워주도록 했습니다.

보통 client.js에서 설계된 XHR 객체 생성은 전송 버튼 클릭이 발생하는 시점에서 생성이 되는데,
xhr-hook.js는 즉시실행함수이기 때문에, index.html이 로드되자마자 XHR프로토타입을 수정해버립니다.
따라서 이후에 XHR을 사용할 일이 있으면 xhr-hook.js에서 덮어씌워놓은 프로토타입으로 XHR객체를 생성하게 됩니다.

+실제 침투 시나리오에서 후킹의 신뢰성을 높이기 위해, xhr-hook.js는 페이지 내의 다른 모든 자바스크립트보다 먼저 실행되어야 하는데,
이를 위해 현재 PoC에서 <head> 섹션의 최상단에 후킹 스크립트를 배치해도 보여주기 용으로는 이쁠것 같습니다.
정말 만약에 탐지룰 중에서 로드되는 스크립트 순서까지 의심점수를 매긴다면 활용도가 조금은 있을 것 같기도 합니다.
+추가 정정: async같은걸 사용해버리는 경우는 스크립트 파일 크기에 따라서 실행 순서가 또 영향을 주기 때문에 스크립트 순서가지고 뭘 평가하는건 억지인것 같습니다.
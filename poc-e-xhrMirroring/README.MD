1. 사용자가 http://localhost:3000에 접속하면 서버가 브라우저에게 index.html을 보내줌
2. index.html에 client.js와 xhr-hook.js가 포함되어있고, 브라우저가 이를 읽으면서 자동으로 실행됨
3. 브라우저가 xhr-hook.js를 읽는순간 4000번 서버로부터 xhr-hook.js가 브라우저에 로드가 됨
4. xhr-hook.js가 실행되면서 브라우저의 기본 XMLHttpRequest객체의 프로토타입 함수가 덮어씌워짐
(이 시점에서 후킹 성공, 엄밀히 말하면 프로토타입 메서드 오버라이드)(프로토타입 덮어쓰기여서 이후 자연스레 생성되는 XHR객체는 xhr-hook.js가 만든 프로토타입 함수를 사용하게 됨)
5. 사용자가 http://localhost:3000에서 여러 전송 버튼들을 누르면, client.js는 정석대로 XHR객체를 생성하여 서버로 전송을 시도합니다
6. 하지만 이미 XHR프로토타입 함수들이 후킹된 상태라서, client.js가 생성한 XHR 객체가 사용하게 될 open(), setRequestHeader(), send()같은 함수들은 정상적인 메서드가 아닙니다.
7. 후킹된 악성 메서드는 원래 가려던 신호를 복사해서 5001,5002,5003번 서버에 멀티 오리진으로 전송합니다.(여러개의 C2서버에 복사하기)
8. 처음에 복사한 신호는 원래 가려던 서버(3000번)에도 똑같이 보내줍니다.(사용자나 서버 입장에서는 정상적으로 신호가 주고 받아진것 처럼 보임)(물론 F12 눌러서 보면 들킴)
9. CMD창으로 3000번,5001번,5002번,5003번의 서버에 수집로그가 뜨는 것을 확인하실 수 있습니다.
10. 수집이 돼서 DB에서 확인할 수 있는건 아닙니다. 그냥 이름만 collect서버이고, 들어온 페이로드를 json.parse를 통해서 적당히 콘솔로그만 띄워주도록 했습니다.

보통 client.js에서 설계된 XHR 객체 생성은 전송 버튼 클릭이 발생하는 시점에서 생성이 되는데,
xhr-hook.js는 즉시실행함수이기 때문에, index.html이 로드되자마자 XHR프로토타입 메서드를 수정해버립니다.
따라서 이후에 XHR을 사용할 일이 있으면 브라우저에서 XHR을 생성하고, 이후 open()이나 send()같은 메서드를 사용하더라도
xhr-hook.js에서 미리 덮어씌워놓은 프로토타입 메서드를 사용하게 됩니다.
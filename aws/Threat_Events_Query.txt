// index.mjs (Node.js 24 / ESM) - Threat_Events Query API
// deps: @aws-sdk/client-dynamodb @aws-sdk/lib-dynamodb

import { DynamoDBClient } from "@aws-sdk/client-dynamodb";
import { DynamoDBDocumentClient, QueryCommand, GetCommand } from "@aws-sdk/lib-dynamodb";

const ddb = DynamoDBDocumentClient.from(new DynamoDBClient({}), {
  marshallOptions: { removeUndefinedValues: true },
});

const TABLE_NAME = process.env.TABLE_NAME || "Threat_Events";
const EVENT_SHARDS = Number(process.env.EVENT_SHARDS || 8);

// Guardrails
const DEFAULT_LIMIT = 50;
const MAX_LIMIT = 200;
const DEFAULT_WINDOW_MS = 24 * 60 * 60 * 1000;
const MAX_WINDOW_MS = 30 * 24 * 60 * 60 * 1000;

const CORS_HEADERS = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Methods": "OPTIONS,GET",
  "Access-Control-Allow-Headers":
    "Content-Type, X-Amz-Date, Authorization, X-Api-Key, X-Amz-Security-Token",
};

function json(statusCode, obj) {
  return {
    statusCode,
    headers: { "Content-Type": "application/json", ...CORS_HEADERS },
    body: JSON.stringify(obj),
  };
}

// 숫자 파라미터를 min/max 범위로 제한
function clampInt(v, def, min, max) {
  const n = Number(v);
  if (!Number.isFinite(n)) return def;
  const i = Math.trunc(n);
  if (i < min) return min;
  if (i > max) return max;
  return i;
}

// 조회 시작 시점을 now 기준 window로 안전하게 보정
function toSinceMs(qs) {
  const now = Date.now();
  const raw = Number(qs?.sinceMs);
  if (!Number.isFinite(raw) || raw <= 0) return now - DEFAULT_WINDOW_MS;

  const safe = Math.min(raw, now);
  const minSince = now - MAX_WINDOW_MS;
  return safe < minSince ? minSince : safe;
}

function padTs13(tsMs) {
  return String(Math.trunc(Number(tsMs))).padStart(13, "0");
}

// ingest 시 사용한 reverse timestamp 생성 로직
function revTs13FromMs(tsMs) {
  // Ingest sk: "T#<revTs>#E#..."
  const rev = 9999999999999 - Math.trunc(Number(tsMs));
  return String(rev).padStart(13, "0");
}

function skUpperBoundFromSinceMs(sinceMs) {
  // sinceMs 이상(최근)만: revTs <= revTs(sinceMs)
  return `T#${revTs13FromMs(sinceMs)}`;
}

function normDay(s) {
  const day = String(s || "").trim();
  if (!/^\d{4}-\d{2}-\d{2}$/.test(day)) return null;
  return day;
}

function normSeverity(s) {
  if (!s) return null;
  const v = String(s).trim().toUpperCase();
  if (v === "HIGH" || v === "MEDIUM" || v === "LOW") return v;
  return "__INVALID__";
}

function safeStr(s, max = 4000) {
  const v = String(s ?? "").trim();
  if (!v) return "";
  return v.length > max ? v.slice(0, max) : v;
}

function encodeNextToken(key) {
  if (!key) return null;
  return Buffer.from(JSON.stringify(key), "utf8").toString("base64url");
}

function isPlainObject(v) {
  return v !== null && typeof v === "object" && Object.getPrototypeOf(v) === Object.prototype;
}

// 토큰 검증 및 디코딩
function decodeNextToken(token) {
  if (!token) return { ok: true, key: undefined };
  let obj;
  try {
    obj = JSON.parse(Buffer.from(token, "base64url").toString("utf8"));
  } catch {
    return { ok: false, reason: "INVALID_nextToken" };
  }
  if (!isPlainObject(obj)) return { ok: false, reason: "INVALID_nextToken" };
  // shard fan-out: token 형태
  // { shards: [{ s:0, lek: {...} }, ...], done: [0,1,...] }
  if (!Array.isArray(obj.shards) && !Array.isArray(obj.done)) {
    return { ok: false, reason: "INVALID_nextToken" };
  }
  return { ok: true, key: obj };
}

function pickItem(it) {
  // 응답 payload는 필요에 따라 더 줄이거나 늘리세요
  return {
    ts: it.tsMs,
    day: it.day,
    type: it.type,
    ruleId: it.ruleId,
    severity: it.severity,
    scoreDelta: it.scoreDelta,
    sessionId: it.sessionId,
    origin: it.origin,
    page: it.page,
    targetOrigin: it.targetOrigin,
    eventId: it.eventId,
    // 필요하면 data/evidence도 내려주되, 기본은 숨기는 걸 권장
    // data: it.data,
    // evidence: it.evidence,
  };
}

// 단일 shard에 대해 sinceMs 기준 최신 이벤트 조회
async function queryOneShard({ pkValue, sinceMs, limit, exclusiveStartKey }) {
  // sinceMs 컷: SK <= upperBound (revTs가 작을수록 최신이므로)
  const params = {
    TableName: TABLE_NAME,
    KeyConditionExpression: "#pk = :pk AND #sk <= :skUpper",
    ExpressionAttributeNames: { "#pk": "pk", "#sk": "sk" },
    ExpressionAttributeValues: {
      ":pk": pkValue,
      ":skUpper": skUpperBoundFromSinceMs(sinceMs),
    },
    Limit: limit,
    ScanIndexForward: true, // revTs 오름차순 = 최신부터
    ExclusiveStartKey: exclusiveStartKey,
  };
  const res = await ddb.send(new QueryCommand(params));
  return { items: res.Items || [], lek: res.LastEvaluatedKey };
}

function revTsFromSk(sk) {
  // sk = "T#<13digits>#E#..."
  const m = /^T#(\d{13})#/.exec(String(sk || ""));
  return m ? m[1] : "9999999999999";
}

// revTs 기준으로 두 shard 결과를 최신순으로 병합
function mergeByRevTs(itemsA, itemsB, limit) {
  // 두 리스트 모두 최신부터(작은 revTs부터) 정렬되어 있다는 가정
  const out = [];
  let i = 0, j = 0;
  while (out.length < limit && (i < itemsA.length || j < itemsB.length)) {
    const a = itemsA[i];
    const b = itemsB[j];
    if (!b) { out.push(a); i++; continue; }
    if (!a) { out.push(b); j++; continue; }
    const ra = revTsFromSk(a.sk);
    const rb = revTsFromSk(b.sk);
    if (ra <= rb) { out.push(a); i++; } else { out.push(b); j++; }
  }
  return out;
}


// ---------- Route handlers ----------
// ORG + DAY 기준 이벤트 리스트 조회 (샤드 fan-out + pagination)
async function handleEvents(event) {
  const qs = event.queryStringParameters || {};
  const origin = safeStr(qs.origin, 400);
  const day = normDay(qs.day);

  if (!origin) return json(400, { ok: false, reason: "MISSING_origin" });
  if (!day) return json(400, { ok: false, reason: "MISSING_or_INVALID_day" });

  const sinceMs = toSinceMs(qs);
  const limit = clampInt(qs.limit, DEFAULT_LIMIT, 1, MAX_LIMIT);
  const nextToken = qs.nextToken ? String(qs.nextToken) : undefined;

  // shard fan-out pagination token
  const decoded = decodeNextToken(nextToken);
  if (!decoded.ok) return json(400, { ok: false, reason: decoded.reason });
  const tokenObj = decoded.key || { shards: [], done: [] };
  const doneSet = new Set(Array.isArray(tokenObj.done) ? tokenObj.done : []);
  const shardState = new Map();
  for (const e of (Array.isArray(tokenObj.shards) ? tokenObj.shards : [])) {
    if (e && Number.isFinite(Number(e.s))) shardState.set(Number(e.s), e.lek);
  }

  // 각 샤드에서 일부씩 뽑아 merge (비용 통제: perShardLimit)
  const perShardLimit = Math.max(1, Math.ceil(limit / 2));
  let merged = [];
  const newShardTokens = [];
  const newlyDone = [];

  // 2개씩 병렬로 Query (동시성 제한)
  const CONCURRENCY = 2;
  const pendingShards = [];
  for (let s = 0; s < EVENT_SHARDS; s++) {
    if (!doneSet.has(s)) pendingShards.push(s);
  }

  for (let i = 0; i < pendingShards.length && merged.length < limit; i += CONCURRENCY) {
    const batch = pendingShards.slice(i, i + CONCURRENCY);

    const results = await Promise.all(batch.map(async (s) => {
      const pkValue = `ORG#${origin}#DAY#${day}#S#${s}`;
      const { items, lek } = await queryOneShard({
        pkValue,
        sinceMs,
        limit: perShardLimit,
        exclusiveStartKey: shardState.get(s),
      });
      return { s, items, lek };
    }));

    for (const r of results) {
      merged = mergeByRevTs(merged, r.items, limit);
      if (r.lek) newShardTokens.push({ s: r.s, lek: r.lek });
      else newlyDone.push(r.s);
      if (merged.length >= limit) break;
    }
  }

  const outToken = encodeNextToken({
    shards: newShardTokens,
    done: Array.from(new Set([...doneSet, ...newlyDone])),
  });

  return json(200, {
    ok: true,
    query: { origin, day, sinceMs, limit },
    items: merged.map(pickItem),
    nextToken: outToken,
  });
}

// 단일 eventId에 대한 상세 BODY 조회
async function handleBody(event) {
  const qs = event.queryStringParameters || {};
  const eventId = safeStr(qs.eventId, 200);
  if (!eventId) return json(400, { ok: false, reason: "MISSING_eventId" });

  const res = await ddb.send(new GetCommand({
    TableName: TABLE_NAME,
    Key: { pk: `EVENT#${eventId}`, sk: "BODY" },
  }));

  if (!res.Item) return json(404, { ok: false, reason: "NOT_FOUND" });
  return json(200, { ok: true, eventId, body: res.Item });
}

// ---------- Router ----------
function getMethod(event) {
  return String(event?.httpMethod || event?.requestContext?.http?.method || "")
    .toUpperCase();
}
function getPath(event) {
  return String(event?.path || event?.rawPath || "");
}

// GET /events, /events/body 라우팅 처리
export const handler = async (event) => {
  try {
    const method = getMethod(event);

    if (method === "OPTIONS") {
      return { statusCode: 204, headers: CORS_HEADERS, body: "" };
    }
    if (method !== "GET") {
      return json(405, { ok: false, reason: "METHOD_NOT_ALLOWED" });
    }
    if (!TABLE_NAME) {
      return json(500, { ok: false, reason: "MISSING_TABLE_NAME" });
    }

    const path = getPath(event);
    // stage prefix가 붙어도 동작하도록 endsWith    
    if (path.endsWith("/events/body")) return await handleBody(event);
    if (path.endsWith("/events")) return await handleEvents(event);

    return json(404, { ok: false, reason: "NOT_FOUND" });
  } catch (err) {
    console.error("query api error:", err);
    return json(500, { ok: false, reason: "INTERNAL_ERROR" });
  }
};

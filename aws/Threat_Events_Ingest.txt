// index.mjs (AWS Lambda - Node.js 24)
// deps: @aws-sdk/client-dynamodb @aws-sdk/lib-dynamodb 
import crypto from "crypto";
import { DynamoDBClient } from "@aws-sdk/client-dynamodb";
import { DynamoDBDocumentClient, PutCommand, UpdateCommand } from "@aws-sdk/lib-dynamodb";

const TABLE = process.env.TABLE_NAME || "Threat_Events";
const AGG_TABLE = process.env.AGG_TABLE_NAME || "Threat_Aggregates";
const TTL_DAYS = Number(process.env.TTL_DAYS || 30);
const MAX_JSON_BYTES = Number(process.env.MAX_JSON_BYTES || 20000);            
const EVENT_SHARDS = Number(process.env.EVENT_SHARDS || 8);      // Events hot partition 완화
const AGG_SHARDS   = Number(process.env.AGG_SHARDS || 4);        // Aggregates hot partition 완화
const EVENT_SCORE_CAP = Number(process.env.EVENT_SCORE_CAP || 50); // server score cap (1차 보정)

const ALLOW_ORIGIN = process.env.ALLOW_ORIGIN || "*";
const ALLOW_HEADERS = "content-type";
const ALLOW_METHODS = "POST,OPTIONS";

const ddb = DynamoDBDocumentClient.from(new DynamoDBClient({}), {
  marshallOptions: { removeUndefinedValues: true },
});

// ---------- HMAC integrity (2차 방어) ----------
const REQUIRE_HMAC = String(process.env.REQUIRE_HMAC || "false").toLowerCase() === "true";
const HMAC_KEY = process.env.HMAC_KEY || "";               // 완전 비밀이 아니라도 "위조 난이도 상승" 목적
const HMAC_VERSION = process.env.HMAC_VERSION || "v1";     // 스키마/서명 문자열 바뀔 때 롤링용

function hmacHex(key, msg) {
  return crypto.createHmac("sha256", key).update(msg, "utf8").digest("hex");
}

function timingSafeEqHex(a, b) {
  // a,b: hex string
  if (typeof a !== "string" || typeof b !== "string") return false;
  if (a.length !== b.length) return false;
  try {
    const ba = Buffer.from(a, "hex");
    const bb = Buffer.from(b, "hex");
    if (ba.length !== bb.length) return false;
    return crypto.timingSafeEqual(ba, bb);
  } catch {
    return false;
  }
}

function getHeader(event, name) {
  const h = event?.headers || {};
  // API GW는 대소문자 섞여 올 수 있음
  return h[name] ?? h[name.toLowerCase()] ?? h[name.toUpperCase()] ?? "";
}

function buildCanonicalV1({
  eventId, tsMs, installId, sessionId, type, ruleId, top_domain, severity, scoreClient, scoreServer,
}) {
  // null/undefined를 빈값으로 고정 (클라/서버 동일 규칙 필요)
  const sc = Number.isFinite(scoreClient) ? String(scoreClient) : "";
  return [
    "v1",
    String(eventId || ""),
    String(tsMs || ""),
    String(installId || ""),
    String(sessionId || ""),
    String(type || ""),
    String(ruleId || ""),
    String(top_domain || ""),
    String(severity || ""),
    sc,
  ].join("|");
}
// ---------------------------------------------


// API Gateway/Lambda URL용 공통 CORS 헤더 생성
function corsHeaders(/* event */) {
  return {
    "content-type": "application/json",
    "access-control-allow-origin": ALLOW_ORIGIN,
    "access-control-allow-methods": ALLOW_METHODS,
    "access-control-allow-headers": ALLOW_HEADERS,
    "access-control-max-age": "600",
  };
}

// JSON 응답 포맷을 통일
function resp(statusCode, bodyObj, extraHeaders) {
  return {
    statusCode,
    headers: { ...corsHeaders(), ...(extraHeaders || {}) },
    body: JSON.stringify(bodyObj),
  };
}

// 객체를 JSON 문자열로 직렬화했을 때 UTF-8 바이트 길이 계산
function jsonByteLength(obj) {
  try {
    return Buffer.byteLength(JSON.stringify(obj ?? null), "utf8");
  } catch {
    return 0;
  }
}

// Ts 13자리 ms timestamp로 정규화
function toTsMs(tsRaw) {
  const n = Number(tsRaw);
  if (!Number.isFinite(n) || n <= 0) return NaN;
  // seconds(10자리대) -> ms
  if (n > 0 && n < 1e12) return Math.trunc(n * 1000);
  return Math.trunc(n);
}

// timestamp(ms)를 13자리 문자열로 zero-pad
function padTs13(tsMs) {
  return String(Math.trunc(tsMs)).padStart(13, "0");
}

// 문자열 변환 + 최대 길이 제한 (DynamoDB 저장 안정성용)
function safeStr(v, maxLen) {
  const s = v == null ? "" : String(v);
  return s.length > maxLen ? s.slice(0, maxLen) : s;
}

function normLower(s, maxLen = 400) {
  return safeStr(s, maxLen).trim().toLowerCase();
}

function stripPort(host) {
  const h = String(host || "").trim();
  // IPv6는 단순 처리(포트 제거만)
  if (h.startsWith("[")) {
    const i = h.indexOf("]");
    return i >= 0 ? h.slice(0, i + 1) : h;
  }
  const idx = h.lastIndexOf(":");
  if (idx > 0 && /^\d+$/.test(h.slice(idx + 1))) return h.slice(0, idx);
  return h;
}

function extractHostFromUrl(urlStr) {
  try {
    const u = new URL(String(urlStr || ""));
    return stripPort(u.host || u.hostname || "");
  } catch {
    return "";
  }
}

function extractPathFromUrl(urlStr) {
  try {
    const u = new URL(String(urlStr || ""));
    return u.pathname || "";
  } catch {
    return "";
  }
}

// 매우 단순한 path 마스킹(PII/식별자 노출 방지 목적)
function maskPath(path) {
  const p = String(path || "");
  if (!p) return "";
  return p
    .split("/")
    .map(seg => {
      if (!seg) return "";
      if (/^\d+$/.test(seg)) return ":n";
      if (/^[A-Za-z0-9\-_]{16,}$/.test(seg)) return ":tok";
      // email/uuid 등은 필요 시 추가
      return seg;
    })
    .join("/")
    .slice(0, 2000);
}


// PSL(정확) 라이브러리 없이도 "위조 난이도 상승/무결성" 목적에 충분한 수준의 보수적 추정
const TWO_LEVEL_SUFFIX = new Set([
  "co.uk", "org.uk", "ac.uk",
  "com.au", "net.au", "org.au",
  "co.jp", "ne.jp", "or.jp",
  "co.kr", "or.kr", "go.kr", "ac.kr",
]);

function deriveTopDomainFromHost(hostOrDomain) {
  const h0 = normLower(stripPort(hostOrDomain), 400).replace(/\.$/, "");
  if (!h0) return "";
  // 이미 domain 형태로 온 경우도 처리
  const parts = h0.split(".").filter(Boolean);
  if (parts.length <= 2) return h0;
  const last2 = parts.slice(-2).join(".");
  const last3 = parts.slice(-3).join(".");
  // 예: news.example.co.uk -> example.co.uk
  if (TWO_LEVEL_SUFFIX.has(last2)) return parts.slice(-3).join(".");
  if (TWO_LEVEL_SUFFIX.has(parts.slice(-2).join("."))) return last3;
  return last2;
}

// Asia/Seoul 기준 시간 단위 집계를 위한 YYYYMMDDHH 키 생성
function isoDayFromTs(ts) {
  const d = new Date(ts);
  const parts = new Intl.DateTimeFormat("en-CA", {
    timeZone: "Asia/Seoul",
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
  }).formatToParts(d);

  const yyyy = parts.find(p => p.type === "year")?.value ?? "0000";
  const mm   = parts.find(p => p.type === "month")?.value ?? "00";
  const dd   = parts.find(p => p.type === "day")?.value ?? "00";

  return `${yyyy}-${mm}-${dd}`; // YYYY-MM-DD
}

// Asia/Seoul 기준 시간 단위 집계를 위한 YYYYMMDDHH 키 생성
function isoHourKeyFromTs(ts) {
  // Asia/Seoul 기준 YYYYMMDDHH
  const d = new Date(ts);
  const parts = new Intl.DateTimeFormat("en-CA", {
   timeZone: "Asia/Seoul",
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    hour12: false,
  }).formatToParts(d);
  const yyyy = parts.find(p => p.type === "year")?.value ?? "0000";
  const mm   = parts.find(p => p.type === "month")?.value ?? "00";
  const dd   = parts.find(p => p.type === "day")?.value ?? "00";
  const hh   = parts.find(p => p.type === "hour")?.value ?? "00";
  return `${yyyy}${mm}${dd}${hh}`; // YYYYMMDDHH
}

/*
* NOTE(scoreBucket):
* ------------------
* severity 받아오기 때문에 안 씀
* function scoreBucket(scoreClient) {
*   const x = Number(scoreClient ?? 0);
*   if (x >= 50) return "HIGH";
*   if (x >= 10) return "MIDDLE";
*   return "LOW";
* }
*/

// JSON payload가 최대 바이트를 넘으면 preview만 저장하고 truncation 표시
function truncateJsonByBytes(obj, maxBytes) {
  try {
    const s = JSON.stringify(obj ?? null);
    const bytes = Buffer.byteLength(s, "utf8");
    if (bytes <= maxBytes) {
      return { json: obj ?? null, truncated: false, bytes };
    }
    // preview는 문자열 일부만(바이트 정확 컷까진 안 하고 “대략적인 프리뷰”)
    return {
      json: { __truncated__: true, preview: s.slice(0, Math.min(2000, s.length)) },
      truncated: true,
      bytes,
    };
  } catch {
    return { json: { __invalid_json__: true }, truncated: true, bytes: 0 };
  }
}

// day(YYYY-MM-DD) 기준 Asia/Seoul 23:59:59 + N일 TTL 계산
function ttlFromDay(day, plusDays) {
  const [y, m, d] = day.split("-").map(Number);
  // Asia/Seoul 기준 day 끝
  const endOfDaySeoul = Date.UTC(y, m - 1, d, 15, 59, 59);
  const ttlMs = endOfDaySeoul + plusDays * 86400 * 1000;
  return Math.floor(ttlMs / 1000);
}

export const handler = async (event) => {
  // 0. CORS preflight 처리
  const method =
    event?.requestContext?.http?.method ||
    event?.requestContext?.httpMethod ||
    event?.httpMethod ||
    "";

  if (String(method).toUpperCase() === "OPTIONS") {
    return {
      statusCode: 204,
      headers: corsHeaders(event),
      body: "",
    };
  }

  // 1. 요청 body 파싱 및 JSON 검증
  let payload;
  try {
    payload =
      typeof event?.body === "string"
        ? JSON.parse(event.body)
        : (event?.body ?? event);
  } catch {
    return resp(400, { ok: false, error: "Invalid JSON body", code: "INVALID_JSON"});
  }

  // 최상위 payload 자체도 너무 크면 컷/거절
  // API Gateway/Lambda URL 자체 제한이 있긴 하지만, 방어적으로 추가
  const payloadBytes = jsonByteLength(payload);
  const MAX_PAYLOAD_BYTES = Number(process.env.MAX_PAYLOAD_BYTES || 450_000); // 여유치(약 450KB)
  if (payloadBytes > MAX_PAYLOAD_BYTES) {
    return resp(413, { ok: false, error: "Payload too large", code: "PAYLOAD_TOO_LARGE"});
  }

  // 2. 필수 필드 최소 검증 (type, sessionId, ts)
  const type = safeStr(payload?.type, 120);
  const ruleId = safeStr(payload?.ruleId, 200);
  const sessionId = safeStr(payload?.sessionId, 120);
  const installId = safeStr(payload?.installId, 120); 
  const tsMs = toTsMs(payload?.ts);
  const eventId = safeStr(payload?.eventId, 200) || safeStr(payload?.reportId, 200);       // 길이는 운영 기준으로 조절

  if (!type) {
    return resp(400, {
      ok: false,
      error: "Missing required field: type",
      code: "MISSING_TYPE",
    });
  }

  if (!sessionId) {
    return resp(400, {
      ok: false,
      error: "Missing required field: sessionId",
      code: "MISSING_SESSION_ID",
    });
  }

  if (!installId) {
    return resp(400, {
      ok: false,
      error: "Missing required field: installId",
      code: "MISSING_INSTALL_ID",
    });
  }

  if (!Number.isFinite(tsMs)) {
    return resp(400, {
      ok: false,
      error: "Invalid or missing required field: ts",
      code: "INVALID_TS",
    });
  }

  if (!eventId) {
    return resp(400, {
      ok: false,
      error: "Missing required field: eventId",
      code: "MISSING_EVENT_ID",
    });
  }

  const origin = safeStr(payload?.origin, 400);
  
  // ---------------------------
  // Unified schema (single truth)
  // ---------------------------
  const server_received_ts_ms = Date.now();

  const page = safeStr(payload?.page, 2000);
  const ua = safeStr(payload?.ua, 400);
  const extension_version = safeStr(payload?.extension_version ?? payload?.extensionVersion ?? "", 100);
  const tags = Array.isArray(payload?.tags)
    ? payload.tags.slice(0, 20).map(t => safeStr(t, 32))
    : undefined;

  // page_host / page_path_masked 는 서버가 URL에서 파생
  const page_host = normLower(extractHostFromUrl(page), 400);
  const page_path_masked = maskPath(extractPathFromUrl(page));
  // top_domain 은 서버가 host 기반으로 계산 (없으면 UNKNOWN)
  const top_domain = deriveTopDomainFromHost(page_host) || "UNKNOWN";

  // severity 표준화
  let severity = safeStr(payload?.severity ?? "LOW", 20).toUpperCase();
  if (!["HIGH", "MEDIUM", "LOW"].includes(severity)) severity = "UNKNOWN";

  // score: 클라는 scoreClient만 보냄 → 서버가 보정 후 scoreServer로 저장
  const scoreClient = Number(payload?.scoreDelta);
  const flags = [];

  let baseScore = 0;
  if (Number.isFinite(scoreClient)) baseScore = scoreClient;
  else {
    if (severity === "HIGH") baseScore = 20;
    else if (severity === "MEDIUM") baseScore = 10;
    else if (severity === "LOW") baseScore = 2;
    else baseScore = 0;
  }

  let scoreServer = Math.max(0, Math.min(baseScore, EVENT_SCORE_CAP));
  if (scoreServer !== baseScore) flags.push("EVENT_SCORE_CAPPED");
  scoreServer = Math.round(scoreServer);

  const now = Date.now();
  const MAX_SKEW_MS = Number(process.env.MAX_TS_SKEW_MS || 7 * 86400 * 1000);
  if (Math.abs(tsMs - now) > MAX_SKEW_MS) {
    return resp(400, { ok: false, error: "ts is out of acceptable range", code: "TS_OUT_OF_RANGE" });
  }

  // ---------- 2차 방어: HMAC 무결성 체크 ----------
  if (REQUIRE_HMAC) {
    if (!HMAC_KEY) {
      // 배포 설정 실수 방지
      return resp(500, { ok: false, error: "HMAC_KEY not configured", code: "MISCONFIG_HMAC_KEY" });
    }

    // 서명은 헤더 우선, 없으면 payload.sig 허용
    const sig = safeStr(getHeader(event, "x-sig"), 200) || safeStr(payload?.sig, 200);
    const sigV = safeStr(getHeader(event, "x-sig-v"), 20) || safeStr(payload?.sig_v, 20) || HMAC_VERSION;

    // 현재는 v1만 지원 (필요하면 v2 추가)
    if (sigV !== "v1") {
      return resp(401, { ok: false, error: "Unsupported signature version", code: "SIG_VERSION_UNSUPPORTED" });
    }
    if (!sig) {
      return resp(401, { ok: false, error: "Missing signature", code: "MISSING_SIGNATURE" });
    }

    const canonical = buildCanonicalV1({
      eventId, tsMs, installId, sessionId, type, ruleId: (ruleId || type), top_domain, severity,
      scoreClient,
    });
    const expected = hmacHex(HMAC_KEY, canonical);
    if (!timingSafeEqHex(expected, sig)) {
      return resp(401, { ok: false, error: "Invalid signature", code: "INVALID_SIGNATURE" });
    }
  }
  // ----------------------------------------------

  const day = isoDayFromTs(tsMs);
  const hourKey = isoHourKeyFromTs(tsMs);
  
  // eventId 기반 해시 (결정적 shard 계산)
  const eventIdHash = crypto.createHash("sha256").update(eventId).digest("hex");

  // Events shard: 항상 동일 eventId -> 동일 shard
  const eventShard = Number.parseInt(eventIdHash.slice(0, 8), 16) % EVENT_SHARDS;

  // SK 길이 제한용 short id (원본도 함께 저장하니 SK는 짧게)
  const eventIdShort = eventIdHash.slice(0, 16);

  // 3. 이벤트 식별 키
  // shard (핫파티션 방지)
  const revTs = String(9999999999999 - tsMs).padStart(13, "0");

  const pk = `ORG#${origin || "UNKNOWN"}#DAY#${day}#S#${eventShard}`;
  const sk = `T#${revTs}#E#${eventIdShort}`;

  // 4. payload(data/evidence) 크기 제한
  const dataPack = truncateJsonByBytes(payload?.data, MAX_JSON_BYTES);
  const evPack = truncateJsonByBytes(payload?.evidence, MAX_JSON_BYTES);

  // 5 TTL 계산
  const ttl = ttlFromDay(day, TTL_DAYS);

  const item = {
    pk, sk,
    eventId,
    tsMs, day,

    type,
    ruleId: ruleId || type,
    sessionId,
    installId,
    
    ii_pk: `INSTALL#${installId}`,
    ii_sk: `T#${revTs}#E#${eventIdShort}`,
    
    origin,
    top_domain,
    page_host, page_path_masked,
    severity,
    scoreClient,
    scoreServer,
    extension_version,
    ua,
    tags,
    server_received_ts_ms,

    ttl,
    flags,
  };

  const bodyItem = {
    pk: `EVENT#${eventId}`,
    sk: "BODY",

    tsMs, day,
    installId,

    data: dataPack.json,
    evidence: evPack.json,
    dataTruncated: dataPack.truncated,
    evidenceTruncated: evPack.truncated,

    ttl,
  };

  // Aggregates shard
  const aggShard = Number.parseInt(eventIdHash.slice(8, 16), 16) % AGG_SHARDS;
  const orgKey = origin || "UNKNOWN";
  const ruleKey = (ruleId || type) || "UNKNOWN";
  const domainKey = top_domain || "UNKNOWN";
  const sevKey = severity || "LOW";

  try {
    // 1 메타 Put
    await ddb.send(new PutCommand({
      TableName: TABLE,
      Item: item,
      ConditionExpression: "attribute_not_exists(pk) AND attribute_not_exists(sk)",
    }));

    // 2 BODY Put
    await ddb.send(new PutCommand({
      TableName: TABLE,
      Item: bodyItem,
    }));
    
    // 3 Aggregates UpdateItem들 (카운터/합계 누적)
    //    - 도메인 랭킹: DAY 단위 DOMAIN 카운트+점수합
    //    - 룰 빈도: DAY 단위 RULE 카운트
    //    - severity: severity 이벤트 카운트
    //
    // NOTE: Put 성공한 경우에만 집계를 수행(멱등/중복 방지)
    const aggUpdates = [];

    // (A) Domain DAY ranking
    aggUpdates.push(ddb.send(new UpdateCommand({
      TableName: AGG_TABLE,
      Key: {
        pk: `ORG#${orgKey}#DAY#${day}#S#${aggShard}`,
        sk: `DOMAIN#${domainKey}`,
      },
      UpdateExpression: "SET #ttl = if_not_exists(#ttl, :ttl) ADD #cnt :one, #scoreSum :sd",
      ExpressionAttributeNames: { "#cnt": "cnt", "#scoreSum": "scoreSum", "#ttl": "ttl" },
      ExpressionAttributeValues: { ":one": 1, ":sd": Number(scoreServer || 0), ":ttl": ttl },
    })));

    // (B) Rule DAY topN
    aggUpdates.push(ddb.send(new UpdateCommand({
      TableName: AGG_TABLE,
      Key: {
        pk: `ORG#${orgKey}#DAY#${day}#S#${aggShard}`,
        sk: `RULE#${ruleKey}`,
      },
      UpdateExpression: "SET #ttl = if_not_exists(#ttl, :ttl) ADD #cnt :one",
      ExpressionAttributeNames: { "#cnt": "cnt", "#ttl": "ttl" },
      ExpressionAttributeValues: { ":one": 1, ":ttl": ttl },
    })));

    // (C) Severity counts
    aggUpdates.push(ddb.send(new UpdateCommand({
      TableName: AGG_TABLE,
      Key: {
        pk: `ORG#${orgKey}#DAY#${day}#S#${aggShard}`,
        sk: `SEV#${sevKey}`,
      },
      UpdateExpression: "SET #ttl = if_not_exists(#ttl, :ttl) ADD #cnt :one",
      ExpressionAttributeNames: { "#cnt": "cnt", "#ttl": "ttl" },
      ExpressionAttributeValues: { ":one": 1, ":ttl": ttl },
    })));

    // (D) RULE trend (DAY x SEV) - stacked bars
    aggUpdates.push(ddb.send(new UpdateCommand({
      TableName: AGG_TABLE,
      Key: {
        pk: `ORG#${orgKey}#TREND#RULE#K#${ruleKey}#S#${aggShard}`,
        sk: `DAY#${day}#SEV#${sevKey}`,
      },
      UpdateExpression: "SET #ttl = if_not_exists(#ttl, :ttl) ADD #cnt :one",
      ExpressionAttributeNames: { "#cnt": "cnt", "#ttl": "ttl" },
      ExpressionAttributeValues: { ":one": 1, ":ttl": ttl },
    })));

    // (E) DOMAIN trend (DAY x SEV) - stacked bars
    aggUpdates.push(ddb.send(new UpdateCommand({
      TableName: AGG_TABLE,
      Key: {
        pk: `ORG#${orgKey}#TREND#DOMAIN#K#${domainKey}#S#${aggShard}`,
        sk: `DAY#${day}#SEV#${sevKey}`,
      },
      UpdateExpression: "SET #ttl = if_not_exists(#ttl, :ttl) ADD #cnt :one",
      ExpressionAttributeNames: { "#cnt": "cnt", "#ttl": "ttl" },
      ExpressionAttributeValues: { ":one": 1, ":ttl": ttl },
    })));

    await Promise.all(aggUpdates);
  } catch (e) {
    // 중복 이벤트는 성공 처리, 그 외 에러는 실패 반환
    const name = String(e?.name || "");
    if (name.includes("ConditionalCheckFailed")) {
      return resp(200, { ok: true, dedup: true, eventId });
    }
    console.error("ddb_put_failed", e);
    return resp(500, { ok: false, error: "Failed to persist event", code: "DDB_WRITE_FAILED"});
  }

  return resp(200, { ok: true, eventId });
};
